import { Video } from '../../components/Video';

# Router

Routers serve as blueprints for defining the API interface, offering a structured way to organize and manage endpoints. One notable feature of this model is the ability to nest routers within a single `Base` router, providing a hierarchical structure that reflects the logical organization of your API.

Moreover, routers can be merged seamlessly across files, allowing you to define routers independently and then consolidate them into a unified `Base` router. This modular approach enhances code organization and maintainability, facilitating better scalability and extensibility of your API.

Exporting the `type` of the `Base` router is recommended as it enables clients, particularly in a monorepo project structure, to specify the server as a `devDependency`. This promotes better dependency management and version control, ensuring consistency and compatibility across different parts of your project.

```ts copy filename="Server side"
import { ptsq } from '@ptsq/server';

const { resolver, router } = ptsq().create();

const createUser = resolver
  .output(
    Type.Object({
      firstName: Type.String(),
      lastName: Type.String(),
    }),
  )
  .mutation(() => {
    return {
      firstName: 'John',
      lastName: 'Doe',
    };
  });

// routers can be nested as you want
const baseRouter = router({
  user: router({
    create: createUser,
  }),
});

export type BaseRouter = typeof baseRouter;
```

<Video src="/assets/router.mp4" />

## On client side

On the client side routers are objects (Proxy objects).
If routers are nested on the server, it creates the nesting on the client side as well.

```ts copy filename="Client side"
import { createProxyClient } from '@ptsq/client';
import type { BaseRouter } from './server';

const client = createProxyClient<BaseRouter>({
  url: 'http://localhost:4000/ptsq',
});

const response = await client.user.create.mutate();
```

## Merging routers

In addition to nesting, routers also support merging using the static `Router.merge` method.
This method creates a new router.
The operation does not change the contents of the original routers in any way and merges the paths of one and the other.
If any of the paths within the routers overlap, the path that enters the merge operation second, from the other router, is always used.

```ts copy filename="Server router merging"
import { Router } from '@ptsq/server';
import { routerA } from './routerA';
import { routerB } from './routerB';

const mergedRouter = Router.merge(routerA, routerB);
```

<Video src="/assets/router-merge.mp4" />
