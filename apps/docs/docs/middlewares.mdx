# Middlewares

Middleware function run before every route call (query, mutation).
If middlewares are piped, then all middlewares runs before route call in piping order.

```ts title="server.ts"
import { createServer, expressAdapter, ExpressAdapterContext } from '@ptsq/server';
import express from 'express';
import { z } from 'zod';
import { userRouter } from './userRouter';
import { getUserFromJWT } from './getUserFromJWT';

const app = express();

const createContext = async ({ req, res }: ExpressAdapterContext) => {
  const user = await getUserFromJWT(req.cookies.jwt);

  return {
    req,
    res,
    user,
  };
};

const { middleware, resolver, router, serve } = createServer({
  ctx: createContext,
});

const isAuthed = middleware(({ ctx, next }) => {
  if (!ctx.user) throw new Error('Must be logged in!');

  return next({
    ctx: {
      user: ctx.user,
    },
  });
});

const protectedResolver = resolver.use(isAuthed);

resolver.query({
  resolve: async ({ ctx /* { user: User | null } */, input /* undefined */ }) => {
    return `Hello, ${ctx.user.name}`;
    // throws Error user can be null
  },
});

protectedResolver.query({
  resolve: async ({ ctx /* { user: User } */, input /* undefined */ }) => {
    return `Hello, ${ctx.user.name}`;
  },
});
```

The `next` function only returns the passed context.
It is only for keep the context type up to date after e.g. `if` condition.

## Middleware pipes

```ts title="server.ts"
const isAuthed = middleware(({ ctx /* { user: User<any> | null } */, next }) => {
  if (!ctx.user) throw new Error('Must be logged in!');

  return next({
    ctx: {
      user: ctx.user,
    },
  });
});

const isAdmin = isAuthed.pipe(({ ctx /* { user: User<any> } */, next }) => {
  if (ctx.user.role !== 'admin') throw new Error('Must be an admin!');

  return next({
    ctx: {
      user: ctx.user,
    },
  });
});

const adminResolver = resolver.use(isAdmin);

const deleteOrganization = adminResolver.mutation({
  //...
  resolve: ({ ctx /* { user: User<'admin'> } */, input }) => {
    //...
  },
});
```

Piping the middleware with another middleware, pass the result context type to the next middleware input.

The middleware type is something like this.

```ts
// the mutation without any middlware
Mutation<{ user?: User | null }>;

// the first middleware get the root context and check if user is undefined
Middleware<{ user?: User | null }, { user: User | null }>;

// the piped middleware get the result context of the first middleware and check if user is null
Middleware<{ user: User | null }, { user: User }>;

// then if you have e.g. mutation with resolver that use the piped middleware
Mutation<{ user: User }>;
```
