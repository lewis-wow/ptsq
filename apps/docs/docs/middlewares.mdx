# Middlewares

Middleware function run before every route call (query, mutation) that the resolver that uses the middleware creates.
The `next` function determines when the next middleware will start.

```ts title="server.ts"
import { createServer, expressAdapter, ExpressAdapterContext } from '@ptsq/server';
import express from 'express';
import { z } from 'zod';
import { userRouter } from './userRouter';
import { getUserFromJWT } from './getUserFromJWT';

const app = express();

const createContext = async ({ req, res }: ExpressAdapterContext) => {
  const user = await getUserFromJWT(req.cookies.jwt);

  return {
    req,
    res,
    user,
  };
};

const { resolver, router, serve } = createServer({
  ctx: createContext,
});

const protectedResolver = resolver.use(({ ctx, next }) => {
  if (!ctx.user) throw new Error('Must be logged in!');

  return next({
    ...ctx,
    user: ctx.user,
  });
});

resolver.query({
  resolve: async ({ ctx /* { user: User | null } */, input /* undefined */ }) => {
    return `Hello, ${ctx.user.name}`;
    // throws Error user can be null
  },
});

protectedResolver.query({
  resolve: async ({ ctx /* { user: User } */, input /* undefined */ }) => {
    return `Hello, ${ctx.user.name}`;
  },
});
```

The `next` function only returns the passed context.
It is only for keep the context type up to date after e.g. `if` condition.

## Run next function before return

You can also run the next function before the return, so the next middlewares runs before the first middleware ends.

It can be usefull for measuring the time for response.

The last middleware that runs is the `resolve` function. It always runs as a last middleware.

```ts title="server.ts"
const measuredResolver = resolver.use(({ ctx, next }) => {
  if (!ctx.user) throw new Error('Must be logged in!');

  const timeStart = performance.now();

  const resolverResult = next({
    ...ctx,
    user: ctx.user,
  });

  const time = performance.now() - timeStart;

  console.log('Time to resolve: ', time);
  console.log('The result of resolver is: ', resolverResult);

  return resolverResult;
});
```

As you can see, you still have to return the resolver result, it is for context type infering and for passing the result up to middlewares that runs before, as you can nest multiple middlewares and the result returns recursively.

The type of the resolver result is

```ts
type ResolverResponse<TContext extends Context> =
  | {
      ok: true;
      data: unknown;
      ctx: TContext;
    }
  | {
      ok: false;
      error: HTTPError;
      ctx: TContext;
    };
```

so you have to determine if the `ok` property is `true` or `false` to access the `data` or `error`.

## Middleware pipes

If middlewares are piped, then all the middlewares runs before the route call in piping order.

```ts title="server.ts"
const protectedResolver = resolver.use(({ ctx /* { user: User<any> | null } */, next }) => {
  if (!ctx.user) throw new Error('Must be logged in!');

  return next({
    ...ctx,
    user: ctx.user,
  });
});

const adminResolver = protectedResolver.use(({ ctx /* { user: User<any> } */, next }) => {
  if (ctx.user.role !== 'admin') throw new Error('Must be an admin!');

  return next({
    ...ctx,
    user: ctx.user,
  });
});

const deleteOrganization = adminResolver.mutation({
  //...
  resolve: ({ ctx /* { user: User<'admin'> } */, input }) => {
    //...
  },
});
```

Piping the middleware with another middleware, pass the context returned from first middleware as a input to the piped (next) middleware.

There is a demonstration how the `Middleware` types work.

```ts
// the mutation without any middlware
Mutation<{ user?: User | null }>;

// the first middleware get the root context and check if user is undefined
Middleware<{ user?: User | null }, { user: User | null }>;

// the piped middleware get the result context of the first middleware and check if user is null
Middleware<{ user: User | null }, { user: User }>;

// then if you have e.g. mutation with resolver that use the piped middleware
Mutation<{ user: User }>;
```
