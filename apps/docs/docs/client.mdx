# Client

The client is a Javascript `Proxy` object.

## Proprietary client

```ts title="client.ts"
import { createProxyClient } from '@ptsq/client';

/**
 * non introspected or generated file, just type of server router
 */
import type { BaseRouter } from './server';

const client = createProxyClient<BaseRouter>({
  url: 'http://localhost:4000/ptsq',
});

const result /* string */ = await client.test.query({
  name: /* string */ 'John',
});
```

## Introspected schema

Even if this is not directly the server router schema, it is introspected, the way you define client stays the same, client does not care if the server is in your repository or somewhere else.

```ts title="client.ts"
import { createProxyClient } from '@ptsq/client';

/**
 * introspected or generated file, no server exposed, ready for open api
 */
import type { RootRouter } from './schema.generated';

const client = createProxyClient<RootRouter>({
  url: 'http://localhost:4000/ptsq',
});

const result /* string */ = await client.test.query({
  name: /* string */ 'John',
});
```

Introspected schema can also has comments with hints what the serialized type is actuall is. So if the response return `DateTime` as a string, then there is a way to describe the `DateTime` scalar on the server, to give hints on the client side.

## Options

```ts
type CreateProxyClientArgs = {
  url: string;
  credentials?: boolean;
  headers?: RequestHeaders | (() => MaybePromise<RequestHeaders>);
};
```

The url is the url of ptsq server e.g. `https://example.com/ptsq/'.
If credentials option is true, then credentials like cookies are sent to the server with every request.
You can also specify headers you want to send such as `Authorization`header and so on.
Headers can be defined as callable funciton, so for example you can get cookies like jwt token in the function that is then passed to`Authorization` header.

```ts title="client.ts"
import { createProxyClient } from '@ptsq/client';
import type { BaseRouter } from './server';

const client = createProxyClient<BaseRouter>({
  url: 'http://localhost:4000/ptsq',
  headers: async () => {
    const jwt = await cookies.get('jwt');

    return {
      Authorization: `Bearer ${jwt}`,
    };
  },
  credentials: true,
});

const result /* string */ = await client.test.query({
  name: /* string */ 'John',
});
```

## Wrong route

The proxy client has `noop` function as Proxy target.
But you cannot call that `noop` function, because `Proxy` object override the `apply` method of that `noop` function.
That `apply` handler is for calling the `query` or `mutate` requests.
There is only one requester for both `query and `mutation`, so they are called the same way.

```ts
const proxyHandler: ProxyHandler<Client<TRouter>> = {
  get: (_target, key: string) => createProxyClientRouter([...route, key]),
  apply: (_target, _thisArg, argumentsList) => client.request(argumentsList[0], argumentsList[1]),
};

const noop = () => {};

const client = new Proxy(noop, proxyHandler);
```

How you can see, you can by for e.g. `@ts-ignore` disable bad route input, because the check is only on the type-level.
If you `query` or `mutate` bad route it throws on the server `BAD_REQUEST` `HTTPError`.

## Request body validation

On the server, the body sent from client is validated by the following schema.
If the validation failed the server throws `BAD_REQUEST` `HTTPError`.

```ts
z.object({
  route: z.string().regex(/^[a-zA-Z]+(\.?[a-zA-Z]+)*$/),
  input: serializableZodSchema.optional(),
}).strict();
```

How you can see there is no validation for if the route exists and has `resolver`. The route is validated in walking the nested `routers`.
As you can expect, if the route has no `resolver`, means that the route is incomplete and should continue, so `node type` is `router` or some preceding route should be terminating, then `BAD_REQUEST` error is thrown by a server.
