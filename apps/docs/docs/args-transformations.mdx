# Arguments transformations

We already know that arguments can chain. But there is much more, input arguments can be transformed by transform function to create clearer resolvers.

Let's say we have simple resolver that has `{ url }` as args, so:

```ts title="Resolver with url argument"
const urlResolver = resolver.args(z.object({ url: z.string().url() }));
```

We cannot use something like `z.instanceOf(URL)` because from the frontend, we obtain some serializable value.

Let's start with the transformation, make the url as the `URL`.

```ts title="URL transformation"
const urlResolverWithTransformation = urlResolver.transformation(
  (input /* { url: string } (from validation before) */) => ({
    ...input,
    url: new URL(input.url),
  }),
);
```

We transformed the value to `URL` instance. How to use it now?

```ts title="URL transformation"
urlResolverWithTransformation
  .output(z.string())
  .query(({ input /* { url: URL } */ }) => url.pathname);
```

We can now use the parsed value from the transformer, the type of the value is infered from the transformation function return type.

## Transformation spawning

You can spawn your transformation anywhere in the object value.

```ts title="Transformation spawning"
const urlResolverWithTransformation = urlResolver.transformation(
  /* { url: string } */ {
    url: (input /* string */) => new URL(input),
  },
);
```

When you are spawning the transformation inside the object, you do not have to copy all the values like before.

## Using transformation in argument chain

The example before was too simple, what about if we want to add arguments chaining to the transformation.

As we know from chapter before, next arguments schema must extends the previous/current one. But what is the schema now if we used the transformation.
The schema stays the same.

```ts title="URL transformation"
urlResolverWithTransformation
  .args(z.object({ url: z.string().url() /* no z.instanceOf(URL) */ }))
  .output(z.string())
  .query(({ input /* { url: URL } */ }) => url.pathname);
```

How you can see, the schema stays the same, even if we used the transformation before. The reason is that the schema validation runs always before the transformation.

Every middleware or resolver has exactly `one` validation schema (always the last one in the chain) and `n` transformation.

## Transformation chain

We can chain transformations in the same way as arguments chaining.

```ts title="URL transformation into pathname"
const pathnameResolver = urlResolverWithTransformation.transformation(
  (input /* { url: URL } */) => ({
    ...input,
    url: input.url.pathname,
  }),
);
```

## Transformation with middlewares

The middleware has also transformed input, same as the resolver.

```ts title="URL transformation with middlewares"
urlResolverWithTransformation.use(({ input /* { url: URL } */, ctx, next }) => {
  console.log(input.url.pathname);

  return next(ctx);
});
```

## Predefined arguments transformers

There are some predefined transformers for simple transformations like Date, URL, Set, Map, coords, color and so on.

You can use them as if they are your custom transformations like in examples before.

```ts title="Predefined transformers"
import { url } from '@ptsq/transformers';

const urlResolverWithTransformation = urlResolver.transformation(
  /* { url: string } */ {
    url: url,
  },
);
```

## Creating custom transformers

It is very simple to create your own custom transformer and extend the repository of predefined transformers, as the transfomer is only function.

So for example there are two examples of code literally copied from predefined transformers `@ptsq/transformers` repository.

```ts title="date transformer from @ptsq/transformers"
export const date = (value: string | number | Date) => new Date(value);
```

Yeah, that's it, really.

```ts title="url transformer from @ptsq/transformers"
export const url = (value: string | URL) => new URL(value);
```

The transformers should not have some kind of validation, the validation should be in the `.args(...)` method, so data that comes to transformer should be fully validated.
That is one of the reasons why transformers are so slim and easy to write.

## Creating transformer with generic input

Sometimes you want to create a transformer with generic input, like Set or Map. There is a way to do that of course.

```ts title="set transformer from @ptsq/transformers"
export const set = <T extends any[]>(value: T) => new Set<T[number]>(value);
```

It's more complicated than without generics, but if you are familiar with generics, its really very simple.

There must be that extends the any array, because of type checking when using the transformer, but if your parser accepts and value, you can use generic without extends.

```ts title="transformer with any generic"
export const array = <T>(value: T) => [value];
```

### Using transformers with generics

There is a small downside of using transfomers with generic input, because the transformer input cannot infer the input type from the `.transformation(...)` correctly, you have to use additional function.

```ts title="Using transformers with generics"
import { set } from '@ptsq/transformers';

const setResolverWithTransformation = urlResolver.transformation(
  /* { mySet: string[] } */ {
    mySet: (input /* string[] */) => set(input),
  },
);
```

## Output transformation

There is no output transformation yet, so the output must be already serialized, as the zod validation schema can be only serializable schema.
