# Scalars

Scalar allows you to create complex types. You can define how to serialize/parse that type.
The scalar returns two zod schemas for `input` and `output` that can be used inside another zod schemas in your application.

On the server side, you always work with the parsed value, so the parsed value comes to resolver and returns from resolver.
Serializing is done after calling the route with that scalar on output.

The serialize schema check the input from the client and the output from the server.

If the client serialize schema fails, then `BAD_REQUEST` is thrown.
If the server side serialize schema fails before sending value to client, then `INTERNAL_SERVER_ERROR` is thrown.

The parse schema check the output of the parse function and of the resolver output before serialization.

```ts title="scalars/URLScalar.ts"
export const URLScalar = scalar({
  parse: {
    schema: z.instanceof(URL), // used to validate parsed value
    value: (arg) => new URL(arg),
  },
  serialize: {
    schema: z.string().url(), // used to validate requst and response
    value: (arg) => arg.toString(),
  },
  description: 'String format of url', // used to describe scalar input for schema
});
```

```ts title="server.ts"
import {
  createServer,
  expressAdapter,
  ExpressAdapterContext,
} from '@ptsq/server';
import express from 'express';
import { z } from 'zod';
import { URLScalar } from './URLScalar';

const app = express();

const createContext = ({ req, res }: ExpressAdapterContext) => ({
  req,
  res,
});

const { resolver, router, scalar, createHTTPNodeHandler } = createServer({
  ctx: createContext,
});

const baseRouter = router({
  urlQuery: resolver.args(z.object({ url: URLScalar.input })).query({
    output: URLScalar.output,
    resolve: ({ input /* { url: URL } */ }) =>
      new URL(`${input.url.href}/pathname`),
  }),
});

export type BaseRouter = typeof baseRouter;

app.use((req, res) =>
  createHTTPNodeHandler({ router: baseRouter, ctx: { req, res } })(req, res),
);

app.listen(4000);
```

```ts title="client.ts"
import { createProxyClient } from '@ptsq/client';
import { BaseRouter } from './server';

const client = createProxyClient<BaseRouter>({
  url: 'http://localhost:4000/ptsq',
});

const result /* string */ = await client.urlQuery.query({
  url: /* string */ 'https://example.com',
});
```

## Date scalar

Just another example of scalar.

```ts title="scalars/DateScalar.ts"
export const DateScalar = scalar({
  parse: {
    schema: z.instanceof(Date),
    value: (arg) => new Date(arg),
  },
  serialize: {
    schema: z.string().datetime(),
    value: (arg) => arg.toISOString(),
  },
  description: 'ISO string format of date',
});
```

On the client side, IDE hints you to use `string` as a query input and of course hints you to expect string as well.

```ts title="client.ts"
import { createProxyClient } from '@ptsq/client';
import { BaseRouter } from './server';

const client = createProxyClient<BaseRouter>({
  url: 'http://localhost:4000/ptsq',
});

const result /* string */ = await client.dateQuery.query({
  date: /* string */ new Date().toISOString(),
});
```

## Scalar description

The description is very useful in schema introspection, cause the introspected schema is generated with that description in comments.

```ts
export interface DateQuery {
  type: 'query';
  nodeType: 'route';
  args: {
    /**
     * ISO string format of date
     */
    date: string;
    hours: number;
  };

  /**
   * ISO string format of date
   */
  output: string;
}
```

So the user knows what format to pass and expect from the server, even it is a string or some other serializable type.
