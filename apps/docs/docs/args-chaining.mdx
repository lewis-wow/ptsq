# Arguments chaining

Input arguments of the `resolver` can be chained to create a complex type or to know the type before the `resolver` resolve function, for example in the `middleware`.

```ts title="server.ts"
const personWithFirstNameResolver = resolver.args({ person: z.object({ firstName: z.string() }) });

const personResolver = personWithFirstNameResolver.args({ person: z.object({ lastName: z.string() }) });

const testQuery = personResolver.query({
  output: z.string(),
  resolve: ({ input /* { person: { firstName: string; lastName: string; } } */ }) /* string */ => {
    return `Hello, ${input.person.firstName} ${input.person.lastName}`;
  },
});
```

The types are merged into one. It is using the `z.intersection` in the background.

## Using arguments chaining with middlewares

You can use the arguments chaining for getting validated input in the `middleware` before the `resolver` run.

```ts title="server.ts"
const personResolver = resolver.args({ person: z.object({ firstName: z.string() }) });

const personWithLogResolver = personResolver.use(({ input /* { person: { firstName: string } } */, ctx, next }) => {
  console.log('Persons first name: ', input.person.firstName);

  return next({
    ...ctx,
    personFirstName: input.person.firstName,
  });
});

const testQuery = personWithLogResolver.args({ person: z.object({ lastName: z.string() }) }).query({
  output: z.string(),
  resolve: ({
    input /* { person: { firstName: string; lastName: string; } } */,
    ctx /* { personFirstName: string } */,
  }) /* string */ => {
    return `Hello, ${input.person.firstName} ${input.person.lastName}`;
  },
});
```

How you can see, you can safely access the `input` cause it is validated by the arguments.

In the example we log the first name and pass the first name into a context, so the `query` can use the context with already assigned persons first name.
